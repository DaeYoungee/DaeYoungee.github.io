---
title: "[Network] Network 6장"
excerpt: "전송 계층(Data Link Layer)에 알아보자"

writer: DaeYoungEE
categories:
  - Network
tags:
  - [Network]
sidebar:
  nav: "counts"

data: 2023-10-27
last_modified_at: 2022-10-27

published: true
---

## 전송계층

전송 계층을 살펴보기전에 앞에서 배운 네트워크 계층을 한번 더 살펴보자.  
네트워크 계층은 다른 네트워크로 데이터를 전송하려면 라우터가 필요하고, 라우팅을 이용하여 현재 네트워크에서 다른 네트워크로 최적의 경로를 통해 데이터 전송을 가능하게 한다.  
<br>

- **라우터의 라우팅 기능을 통해 데이터를 전송하더라도 목적지에 도착하지 못할 수 있지 않을까?**  
  정답!! 라우팅 경로가 잘못되거나, 라우터를 경유하는 도중 라우터에 문제가 생기거나 패킷이 손상될 수 있기 때문이다.

물리 계층, 데이터 링크 계층, 네트워크 계층의 3계층이 있으면 목적지에 데이터를 보낼 수 있다. BUT 데이터가 손상되거나 유실되더라도 이 3개의 계층에서는 아무것도 해주지 않는다.  
 즉, **전송 계층**은 목적지에 신뢰할 수 있는 데이터를 전달하기 위해 필요하다.
<br>  
전송 계층에는 오류를 점검하는 기능이 있어 오류가 발생하면 데이터를 재전송한다.  
<br>
아래의 그림과 같이 컴퓨터가 데이터를 받아도 어떤 애플리케이션에 전달해야 하는지 모르면 곤란하다.  
그래서 해당 데이터가 어떤 애플리케이션에서 사용하는 데이터인지 판단해야 한다. 예를 들어 홈페이지에서 사용하는 데이터인데 메일 프로그램에 전송하면 안되는 것처럼 말이다. 그래서 **전송 계층에서는 전송된 데이터의 목적지가 어떤 애플리케이션인지 식별하는 기능**도 있다.

<div align="center">
  <img alt="transport layer 기능" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/7ee2d27a-c910-40a6-af56-8a2034f9abfc">   
</div>

> 즉, 네트워크 계층에서는 목적지까지 데이터를 전달하고, 전송 계층에서는 데이터가 제대로 도착했는지 확인한다.  
> 전송 계층의 추가적인 기능으로 전송된 전송된 데이터가 어떤 애플리케이션에 전송해야 하는지 알려 준다.

## 연결형 통신과 비연결형 통신

전송 계층의 특징을 간단히 설명하면 신뢰성/정확성과 효율성으로 구분할 수 있다. 신뢰성/정확성은 데이터를 목적지에 문제없이 전달하는 것, 효율성은 데이터를 빠르고 효율적으로 전달하는 것이다.  
<br>
**연결형 통신**은 신뢰활 수 있고 정확한 데이터를 전달하는 통신, 대표적인 프로토콜은 **TCP**가 있다.  
**비연결형 통신**은 효율적으로 데이터를 전달하는 통신(정확한 데이터 전송보다 빠른 전송), 대표적인 프로토콜은 **UDP**가 있다.  
<br>
아래의 사진처럼 연결형 통신은 상대방과 확인해 가면서 통신하는 방식, 비연결형 통신은 상대방을 확인하지 않고 일반적으로 데이터를 전송하는 방식이다.

<div align="center">
  <img alt="연결형 통신과 비연결형 통신" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/eec0dfaf-5424-4ce8-8833-61e9c39d9181">   
</div>

**신뢰성과 정확성이 보장되지 않는 비연결형 통신을 사용하는 경유가 있나?**  
동영상을 볼 때 비연결형 통신을 사용한다. 동영상은 신뢰할 수 있고 정확한 데이터 전송보다 빠른 전송이 필요하기 때문이다.  
데이터가 늦게 도착해서 화면이 버벅거리는 동영상을 보는 것보다는 데이터가 약간 유실되더라도 원활하게 보는 것이 좋기 떄문!!

## TCP

신뢰성과 정확성을 우선으로 하는 연결형 통신 프로토콜 TCP. TCP 프로토콜에서 데이터를 전송할 때 **가상의 독점 통신로**인 **connection**을 확보해야 한다. 연결을 확보한 후에 데이터를 전송할 수 있다.

- 세그먼트  
  TCP 헤더가 붙은 데이터를 **세그먼트**라고 한다. (참고, 네트워크 계층에서는 **IP패킷**, 데이터 링크 계층에서는 **프레임**이라고 불렀다.)  
  TCP 헤더는 목적지까지 데이터를 제대로 전송하기 위해 필요한 정보를 가지고 있다.

- 코드 비트  
코드 비트는 TCP 헤더의 107번째 비트부터 112번째 비트까지의 6비트로 연결의 제어 정보가 기록되는 곳이다.  
초깃값은 0이고 비트가 활성화되면 1이 된다. 이 중, **connection**을 확립하려면 SYN과 ACK가 필요하다. SYN은 **연결 요청**, ACK는 **확인 응답**이다.
<div align="center">
  <img alt="TCP헤더의 코드 비트" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/75bf4301-67fd-48ec-a650-07994bb611d7">   
</div>

### 3-way 핸드쉐이크

연결을 확립하기 위해 패킷 요청을 세번 교환하는 것을 3-way 핸드셰이크라고 한다.

<div align="center">
  <img alt="TCP헤더의 코드 비트" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/3047181e-0496-4cc5-8ed0-3d5e42dbf4fa">   
</div>

1.  통신을 하려면 컴퓨터 2에게 허가를 받아야 하므로, 먼저 컴퓨터 1에서 컴퓨터 2로 연결 확립 허가를 받기 위한 요청(SYN)을 보낸다.
2.  컴퓨터 2는 컴퓨터 1이 보낸 요청을 받은 후에 허가한다는 응답을 회신하기 위해 연결 확립 응답(ACK)를 보낸다. 동시에 컴퓨터 2도 컴퓨터 1에게 데이터 전송 허가를 받기 위해 연결 확립 요청(SYN)을 보낸다.
3.  컴퓨터 2의 요청을 받은 컴퓨터 1은 컴퓨터 2로 허가한다는 응답으로 연결 확립 응답(ACK)를 보낸다.  
<br>
위의 3-way 핸드쉐이크 과정을 거치면 아래의 사진과 같이 SYN과 ACK의 비트가 1로 활성화 된다.
<div align="center">
  <img alt="TCP헤더의 코드 비트" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/655772c8-641f-4273-ba04-7cb03150836d">   
</div>

### 연결 종료

데이터를 전송했으면 연결을 끊기 위한 요청을 해야한다. 연결을 끊을 때는 **FIN**과 **ACK**를 사용한다. **FIN**은 연결 종료를 뜻한다.

<div align="center">
  <img alt="TCP헤더의 코드 비트" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/770c4460-34f1-4f53-9f3f-6cfd51b32009">   
</div>

1. 컴퓨터 1에서 컴퓨터 2로 연결 종료 요청(FIN)을 보낸다.
2. 컴퓨터 2에서 컴퓨터 1로 연결 종료 응답(ACK)을 반환한다.
3. 또한 컴퓨터 2에서도 컴퓨터 1로 연결 종료 요청(FIN)을 보낸다.
4. 컴퓨터 1에서 컴퓨터 2로 연결 종료 응답(ACK)를 반환한다.

> 연결을 확립할 때는 SYN을 사용, 연결을 종룔할 때는 FIN을 사용, 요청에 대한 응답으로는 ACK를 사용한다.

위의 연결 종료 과정을 거치면 아래의 사진과 같이 FIN과 ACK의 비트가 1로 활성화 된다.

<div align="center">
  <img alt="TCP헤더의 코드 비트" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/b5adcc6b-47d3-458a-bd8c-1b5fc6f4f41a">   
</div>

### 일련번호와 확인 응답 번호

TCP에서 3-way 핸드쉐이크가 끝나고 실제 데이터를 주고 받을 때 **일련번호**와 **확인 응답 번호**를 사용한다.

<div align="center">
  <img alt="TCP헤더의 일련번호, 확인 응답 번호" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/d2abddfd-e2d7-4858-8ff4-5d840b0ee6c9">   
</div>
   
- 일련번호   
송신 측에서 수신 측에 '이 데이터가 **몇 번째 데이터**인지' 알려주는 역할, 전송된 데이터에 일련번호를 부여하면 수신자는 원래 데이터의 **몇 번째 데이터**를 받았는지 알 수 있다. 일련번호는 '순서', '연속된 번호'라는 뜻이 있다.   
- 확인 응답 번호
수신 측이 몇 번째 데이터를 수신했는지 송신 측에 알려주는 역할을 한다. 그래서 이 번호는 다음 번호의 데이터를 요청하는데도 사용한다. ex) 10번 데이터르 수신하면 11번 데이터를 송신 측에 요청한다.

말로만 설명 했을 때 이해가 되지 않을 수 있다. 아래의 사진을 보고 이해해보자. 일련번호 '3001'번은 지금 보내는 200바이트 데이터의 첫 번째 바이트의 번호이다.

<div align="center">
  <img alt="일련번호, 확인 응답 번호 예시" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/2a64d729-3950-4faf-9357-17e585afa697">   
</div>
여기서 확인 응답 번호가 이해가 되지 않을 수 있다. 3001번 부터 시작해서 200바이트를 받았으면 3202번부터 데이터를 보내달라고 요청하는 확인 응답 번호를 보내야 되지 않을까 하는 의문이 들수있다.

<br>
내가 한가지 예시를 들어 이해시켜 보이려한다.   
3001번의 일련번호와 10바이트의 데이터를 받았다고 해보자. 그랬을 때 3001,3002,3003,3004,3005,3006,3007,3008,3009,3010 까지의 10바이트의 연속된 인덱스 데이터를 받은 것이다. 따라서 다음에 3011번부터 보내달라고 요청해야 하기 때문에 확인 응답 번호는 3011인 것이다.

<br>

- 재전송 제어  
 데이터가 항상 올바르게 전달되는 것은 아니므로 일련번호와 확인 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송하게 되어 있다. 이것을 **재전송 제어**라고 한다.
<div align="center">
  <img alt="윈도우 크기" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/223f5218-54bb-496f-bfbc-5219e875d394">
</div>

### 윈도우 크기

지금까지 설명한 통신방법은 **세그먼트** 하나를 보낼 때마다 확인 응답을 한 번 반환하는 통신이다. 이와 같은 방법은 효율이 낮은 방법이다. 확인 응답이 오지 않으면 다음 세그먼트를 보내지 못하고 **기다리기** 때문이다.

<br>
버퍼가 있기 떄문에 세그먼트를 연속해서 보낼 수 있고 이런 통신 방법을 이용했을 때 효율이 높아진다.

- 수신측 버퍼의 크기를 어떻게 알죠? 오버플로우가 일어날 수 있지 않나요?  
  오버플로우가 일어나지 않게 **버퍼의 한계 크기**를 알고 있어야 한다. 그것이 TCP 헤더의 **윈도우 크기** 값에 해당한다.

- 윈도우 크기
윈도우 크기는 **얼마나 많은 용량의 데이터를 저장해 둘 수 있는지**를 나타낸다. 확인 응답을 받지 않아도 연속해서 세그먼트를 보낼 수 있는 데이터의 크기이다.  
 윈도우의 크기의 초깃값은 3-way 핸드쉐이크를 할 때 판단한다. 아래의 예시를 보고 이해하자.
<div align="center">
<img alt="윈도우 크기 예시" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/a4feaabf-08f0-4f1d-85dc-35516ae8bac5">
</div>

<br>
세그먼트를 하나 보내고 확인응답 받는 통신은 아래의 사진과 같다.
<div align="center">
<img alt="세그먼트 하나씩 보낼 때 통신과정" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/b19bed36-3a6b-48e2-8992-6b5f707b5fd8">
</div>

<br>
확인 응답을 기다리지 않고 세그먼트를 연속해서 보내면 아래의 그림과 같다.
<div align="center">
<img alt="세그먼트 하나씩 보낼 때 통신과정" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/55460a0f-324f-490e-8806-c7a92a775c44">
</div>
<br>

> TCP가 데이터를 정확하게 전달할 수 있는 전송계층의 기능  
> 연결 확립, 재전송 제어, 윈도우 제어

## 포트 번호

전송계층의 또 다른 기능으로 전송된 데이터의 목적지가 어떤 애플리케이션(웹 브라우저, 메일 프로그램) 인지 구분하는 역할이다. 전송 계층이 애플리케이션을 구분할 수 있도록 도와주도록 **출발지 포트 번호**(source port number), **목적직 포트 번호**(destination port number)가 필요하다.

<div align="center">
<img alt="세그먼트 여러개 보낼 때 통신과정" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/4b5f5507-b861-4f72-83c5-3cfa090c0ee5">
</div>
<br>

포트 번호는 0~65535번을 사용할 수 있다. 0~1023번 포트는 주요 프로토콜이 사용하도록 예약되어 있다. 이런 포트트 **잘 알려진 포트**(well-known port)라고 한다. 1024번은 예약되어 있지만 사용되지 않는 포트고, 1025번 이상은 **랜덤 포트**라고 해서 클라이언트 측의 송신 포트로 사용한다.  
<br>

0~1023번 포트는 일반적으로 서버 측 애플리케이션에서 사용되고 있다.  
포트번호는 실제로 볼 수 있는 것이 아니라 상상하기 어려울 것이다. 이해하기 쉬운 예시로 아파트의 주인과 방으로 설명할 수 있다.

<div align="center">
<img alt="포트 번호 예시" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/ed937fc7-9561-44cf-8430-47f0e7c32c4f">
</div>
설명: A씨(애플리케이션)에게 짐(데이터)를 보내려면 방 번호(포트 번호)가 '22'인 방에 보내면 된다.   
여기서 방 번호는 서버에서 주로 사용되는 애플리케이션 번호다.   
<div align="center">
<img width="400" alt="잘 알려진 포트 번호" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/bb8302f4-279c-492b-9e26-33d64a8cf56d">
</div>
<br>

데이터를 전송할 때는 상대방의 IP 주소가 필요하지만, 어떤 애플리케이션이 사용되고 있는지 구분하려면 TCP는 포트 번호가 필요하다.  
즉, 포트 번호를 붙이지 않고 통신하면 컴퓨터에 데이터가 도착하더라고 애플리케이션까지는 도착할 수 없다.  
<br>

<div align="center">
<img alt="클라이언트 서버 통신 시 포트번호" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/400dc0eb-0899-4ed8-b7c5-95db396e488b">
</div>

컴퓨터 1에서 컴퓨터 2까지 포트번호를 붙여서 통신하면 확실하게 원하는 애플리케이션까지 데이터를 보낼 수 있다.

- 컴퓨터 1의 웹 브라우저로는 왜 1025번 포트 번호가 할당된 거죠?  
  웹 브라우저로 접속할 때 웹 브라우저에는 임의의 포트가 자동으로 할당된다.

> 즉, 서버 측에서는 포트 번호를 정해야 되지만 클라이언트 측은 정하지 않아도 된다.

## UDP

UDP는 비연결형 통신으로 데이터를 효율적으로 빠르게 보내는 것을 목표로 한다. 스트리밍 방식으로 전송하는 동영상 서비스와 같은 곳에 사용된다.

UDP 헤더가 붙은 데이터를 **UDP 데이터그램**이라고 한다. UDP 헤더는 TCP 헤더에 비해 쓸쓸한 헤더이다.(신뢰성과 정확성이 필요하지 않아 이 정보만으로도 충분하다.)

<div align="center">
<img alt="UDP 헤더" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/5a003fcf-3ba9-46df-ab87-e6b7fc3ce443">
</div>
<br>

TCP는 수신측에 여러 번 확인 응답을 보내면서 전송하지만, UDP는 효율성과 빠른 속도가 중요해서 상대방을 확인하지 않고 연속해서 데이터를 보낸다. 아래의 사진을 보고 이해해보자.

<div align="center">
<img alt="TCP와 UDP" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/81621354-bd04-4623-a607-1329fcfd7272">
</div>
<br>

- 브로드캐스트  
  UDP를 사용하면 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수 있다. 이것을 **브로드캐스트**라고 한다.

<div align="center">
<img alt="TCP와 UDP" src="https://github.com/DaeYoungee/DaeYoungee.github.io/assets/121485300/0129a06e-449d-481d-8fcc-39cb243972a8">
</div>
<br>

- TCP에서는 브로드캐스트가 불가능한가?  
  정답부터 얘기해보자면 불가능하다. TCP는 3-way 핸드셰이크와 같이 데이터를 전송할 때도 확인 응답을 하나씩 보내야 하기 때문에 브로드캐스트와 같이 불특정 다수에게 보내는 통신에는 적합하지 않다.
  > UDP에서의 브로드캐스트는 목적지에 관계없이 랜에서 일괄적으로 보내지만, TCP는 목적지를 지정하지 않으면 안 되기 때문에 **일괄 통신이 불가능**하다.
